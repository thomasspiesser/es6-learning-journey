{"version":3,"sources":["../code/objectBased.js"],"names":[],"mappings":";;;;AAEA,IAAI,QAAQ;AACV,WAAS,mBAAW;AAClB,WAAO,YAAP,CADkB;GAAX;CADP;;;;;;;;AAYJ,IAAI,SAAS,OAAO,MAAP,CAAc,KAAd,CAAT;;;;AAIJ,OAAO,IAAP,GAAc,YAAW;AACvB,SAAO,UAAP,CADuB;CAAX;AAGd,OAAO,OAAP,GAAiB,2BAAjB;;AAEA,QAAQ,GAAR,CAAa,OAAO,OAAP,EAAb;;;;;;AAOA,IAAM,WAAW;AACf,8BAAU;AACR,WAAO,YAAP,CADQ;GADK;CAAX;;AAMN,IAAI,YAAY;AACd,wBAAO;AACL,WAAO,UAAP,CADK;GADO;;AAId,WAAS,2BAAT;CAJE;;AAOJ,OAAO,cAAP,CAAsB,SAAtB,EAAiC,QAAjC;;AAEA,QAAQ,GAAR,CAAa,UAAU,OAAV,EAAb;;;;;;AAMA,IAAM,SAAS;AACb,QAAM,SAAN;AACA,sBAAM;AACJ,qBAAe,KAAK,IAAL;AADX,GAFO;CAAT;;;AAQN,YAAY,OAAO,MAAP,CAAc,SAAd,EAAyB,MAAzB,CAAZ;;AAEA,IAAM,UAAU,OAAO,MAAP,CAAc,SAAd,CAAV;AACN,IAAM,UAAU,OAAO,MAAP,CAAc,SAAd,CAAV;AACN,QAAQ,IAAR,GAAe,OAAf;;AAEA,QAAQ,GAAR,CAAa,QAAQ,GAAR,EAAb;AACA,QAAQ,GAAR,CAAa,QAAQ,GAAR,EAAb","file":"objectBased.js","sourcesContent":["//ES5\n//object literal:\nvar human = {\n  breathe: function() {\n    return 'breathing…';\n  }\n};\n\n// \"inheritance\" aka. set the prototype of worker to human-object using the \n// Object.create function. This chains the worker object to the human object\n// through the prototype link. If we call a function on worker that cannot\n// be found, js will look through the prototype chain to see if it can\n// find the function further up the chain. In this case, it will find .breathe()\n// not in the worker object but up the prototype chain in the human object.\nvar worker = Object.create(human);\n\n// add some properties to the worker object - cannot use object literals, because\n// the object already exists\nworker.work = function() {\n  return 'working…';\n};\nworker.company = 'best company in the world';\n\nconsole.log( worker.breathe() ); // returns 'breathing…\n\n\n// ES6\n// Object.setPrototypeOf makes it possible to use object literals for both objects\n// might have performance issues - maybe keep using .create method\n\nconst es6human = {\n  breathe() {\n    return 'breathing…';\n  }\n};\n\nlet es6worker = {\n  work() {\n    return 'working…';\n  },\n  company: 'best company in the world'\n};\n\nObject.setPrototypeOf(es6worker, es6human);\n\nconsole.log( es6worker.breathe() ); // returns 'breathing…'\n\n// now to assign instance specific behavior that we want available on multiple\n// prototypes, we just create an object, instead of using classes and copy it onto\n// another object or prototype using Object.assing\n\nconst canEat = {\n  food: 'nothing',\n  eat() {\n    return `eats ${this.food}`; // template string (part of ES6)\n  }\n};\n\n// assign copies the values. much like extend.\nes6worker = Object.assign(es6worker, canEat);\n\nconst worker1 = Object.create(es6worker);\nconst worker2 = Object.create(es6worker);\nworker2.food = 'apple';\n\nconsole.log( worker1.eat() ); // 'eats nothing'\nconsole.log( worker2.eat() ); // 'eats apple'\n\n"]}