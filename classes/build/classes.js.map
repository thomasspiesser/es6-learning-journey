{"version":3,"sources":["../code/classes.js"],"names":[],"mappings":";;;;;;;;;;;;IAEqB;;;;;AAInB,WAJmB,QAInB,CAAY,IAAZ,EAAkB;0BAJC,UAID;;AAChB,SAAK,KAAL,GAAa,IAAb,CADgB;GAAlB;;;;;;eAJmB;;2BAUZ;AACL,WAAK,KAAL,GAAa,IAAb,CADK;;;;gCAGK;AACV,UAAI,KAAK,KAAL,EAAY;AACd,eAAO,OAAP,CADc;OAAhB;;;;8BAIQ;AACR,UAAI,CAAC,KAAK,KAAL,EAAY;AACf,eAAO,QAAP,CADe;OAAjB;AAGA,aAAO,KAAK,KAAL,CAJC;;;;6BAMD;AACP,aAAO,SAAP,CADO;;;;;;;wBAKE;AACT,aAAO,KAAK,KAAL,CAAW,WAAX,EAAP,CADS;;sBAGF,SAAS;AAChB,UAAI,OAAJ,EAAa;AACX,aAAK,KAAL,GAAa,OAAb,CADW;OAAb;;;;;;;;;;4BASa,OAAO;AACpB,UAAG,MAAM,IAAN,EAAY;AACb,eAAO,IAAI,QAAJ,CAAa,MAAM,IAAN,CAApB,CADa;OAAf;;;;SA3CiB;;;;;;AAiDrB,IAAM,YAAY,IAAI,QAAJ,CAAc,QAAd,CAAZ;;AAEN,QAAQ,GAAR,CAAa,UAAU,OAAV,EAAb;;;AAGA,QAAQ,GAAR,CAAa,UAAU,IAAV,CAAb;;;AAGA,UAAU,IAAV,GAAiB,WAAjB;AACA,QAAQ,GAAR,CAAa,UAAU,IAAV,CAAb;;;AAGA,IAAM,SAAS,SAAS,SAAT,CAAmB,MAAnB,CAA0B,IAA1B,EAAT;AACN,QAAQ,GAAR,CAAa,MAAb;;;AAGA,QAAQ,GAAR,CAAa,SAAS,OAAT,CAAb;AACA,QAAQ,GAAR,CAAa,UAAU,OAAV,CAAb;;;;AAIA,SAAS,SAAT,CAAmB,SAAnB,GAA+B,YAAY;AACzC,SAAO,YAAP,CADyC;CAAZ;AAG/B,QAAQ,GAAR,CAAa,UAAU,SAAV,EAAb;;;;;AAKA,IAAM,SAAS,EAAC,MAAM,OAAN,EAAV;AACN,IAAM,UAAU,SAAS,OAAT,CAAiB,MAAjB,CAAV;AACN,QAAQ,GAAR,CAAa,QAAQ,IAAR,CAAb;;;AAGA,SAAS,OAAT,GAAmB,UAAU,MAAV,EAAkB;AACnC,UAAQ,GAAR,CAAa,MAAb,EADmC;CAAlB;;AAInB,QAAQ,GAAR,CAAa,SAAS,OAAT,CAAiB,MAAjB,CAAb;AACA,QAAQ,GAAR,CAAa,SAAS,OAAT,CAAb","file":"classes.js","sourcesContent":["// Definition\n\nexport default class Employee {\n  // Every class may specify a constructor. The runtime will invoke the\n  // constructor when instantiating a class. Use the constructor to initialize\n  // state in an object, often by accepting parameters in the constructor method.\n  constructor(name) {\n    this._name = name;\n  } // no comma here - not allowed, semi-colon ; would be ok but ignored\n  // The following methods will be available on every object/instance we create using\n  // new Employee(), (i.e. they are called instance members). This is why, they\n  // can save and retrieve state inside the object using the 'this' keyword.\n  hire() {\n    this.hired = true;\n  }\n  getStatus() {\n    if (this.hired) {\n      return \"hired\";\n    }\n  }\n  getName() {\n    if (!this._name) {\n      return 'Anonym';\n    }\n    return this._name;\n  }\n  doWork() {\n    return 'working';\n  }\n  // Define properties with get and set to encapsulate the fields - allows to \n  // use the property directly\n  get name() {\n    return this._name.toUpperCase();\n  }\n  set name(newName) {\n    if (newName) {\n      this._name = newName;\n    }\n  }\n  // A class may contain one or more methods defined with the keyword static.\n  // The static keyword will create a method associated with the class, but not\n  // with an instance of the class -> no access to 'this' (the instance).\n  // A static method is associated with the constructor function and not the\n  // prototype object like the instance members.\n  static convert(input) {\n    if(input.name) {\n      return new Employee(input.name);\n    }\n  }\n}\n\nconst developer = new Employee( 'Thomas' );\n\nconsole.log( developer.getName() ); // Thomas\n\n// this works because of the getter\nconsole.log( developer.name ); // THOMAS\n\n// this works because of the setter\ndeveloper.name = 'Thomasito';\nconsole.log( developer.name ); // THOMASITO\n\n// “borrowing” a method from a prototype object:\nconst result = Employee.prototype.doWork.call();\nconsole.log( result ); // working\n\n// static methods are defined on the class not the instance\nconsole.log( Employee.convert ); // [Function: convert]\nconsole.log( developer.convert ); // undefined\n\n// if I meddle with the prototype, I will change all instances of that class.\n// Careful!!!\nEmployee.prototype.newMethod = function () {\n  return 'new method';\n}\nconsole.log( developer.newMethod() ); // new method\n\n// use static methods as factory methods, conversion methods, or general class\n// helper methods\n// e.g.\nconst person = {name: 'Peter'};\nconst newHire = Employee.convert(person);\nconsole.log( newHire.name ); // PETER\n\n// new static method goes in the constructor itself\nEmployee.println = function (string) {\n  console.log( string );\n}\n\nconsole.log( Employee.println('yeah') ); // undefined at runtime and 'yeah' at class initianlization - remember its in the constructor, meaning on the class not the instance!\nconsole.log( Employee.println ); // Function\n"]}